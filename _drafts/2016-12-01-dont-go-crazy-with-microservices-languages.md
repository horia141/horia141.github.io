---
published: false
---
One of the architectural patterns for building web applications is [microservices](http://martinfowler.com/articles/microservices.html). There are [many](http://martinfowler.com/articles/microservice-trade-offs.html) [pros](http://eugenedvorkin.com/seven-micro-services-architecture-advantages/) [and](https://www.infoq.com/news/2015/03/benefits-microservices) [cons](http://highscalability.com/blog/2014/4/8/microservices-not-a-free-lunch.html) bandied about with regards to them. But one of the most pervasive is that of being able to use multiple programming languages and tech stacks across a project. More precisely, because each service is sealed-off from the others through very-hard interfaces, it's possible to change the implementation from one language to another, while still maintaining the same API and requiring the same dependencies of other components. Use the right tool for the right job, or at least, keep the engineers happy by using the latest and shinyest tech.

However, I feel this advantage has been oversold. I'd argue it's more of a net neutral feature, if not a negative one, in the wrong hands. The rest of this post will give some argumentation for this point. It's by no means something which should put people off microservices. It's more like a warning to know what you're getting yourself into.

The core of the issue has to do with client libraries. Except in the most simple of cases, ooe


An example I think will shed some light. A common piece of functionality to break off into a microservice is email sending. Regardless of the way email is sent, whether it be directly, or through a third-party provider such as [SendGrid](https://sendgrid.com/) or [MailChimp](https://mailchimp.com/), there usually needs to be a single service which handles that communication. That way, the complex interface exposed by the carrier is wrapped into operations which make sense for the application, security rules can be enforced etc. There's only one point to audit as well. Furthermore, email sending is something which happens asynchronously to the originator task. So putting all this complexity in a single service makes total sense.

Now, suppose there are various other services which are clients of the mail service. 

One of the better architectueal patterns for building web applications is microservives. Now, there are many pros and cons to this, over other aproaches as well as in general. But one pro which is often brandied isthat of being able to use multiple programming languages. And indeed one can go that route. And there arr advantage s from using the right tool for the job to sinply keeping enhineers entertained by alloeing them to use newer tools. However, there is ap price to pay. Services often benefit from having a SDk like library, which provides definitions for objects emlliyef by the service and ways to call into the service, at higher abstraction level than HTTP calls. The more complex the service, the more needed such libratied are. However, if the service is called by many other services, all written in different languages, a copy of. The library is neee.oneer InInevrg  And the more services there are, the more libraries there need to be. Which, means both repeated effort as well as the work to keep things in sync. The more services there after the more this becomes burden. That's a lot of extra "infrastructure" work that needs to happen as well. Timeoutsandretrieis, security, access control, error reporting etc. Let alone the impedance mismatch between languages. Some want future based API, some a boxing ones, othets make use of threads pools and other helpers. All places in which divergence points can occur. Some are types while some are not.
One attempt to fix this is serialization and service definition languages S such as protocol buffets, thrift etc. They do solve. Some bits, but the data representation is usually not enough, lacking support for expressing actions dtc etc. The service bits are, at least at the open source level, not great for the majority of languages. There a while lot of http, json, Ajax infrastructure already in place for an HTTP version.
