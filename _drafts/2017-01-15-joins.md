---
published: false
---
Joins are a perenial source of grief among web programmers, especially those who don't interact that much directly with the database. However, they're an indispensible and quite powerful tool.

In a standard setting, joins are used to do something pretty simple, which can best be described as "fetch other data related to the data I already have". I believe this is the most common use case as well, and it's a pity it's not put more often in the forefront.

Suppose you hava a bookshop database which looks something like this:

{% highlight sql %}
create table Book (
  id int,
  name varchar
);

create table Review (
  id int,
  book_id int foreing key (Book.id),
  text varchar
);
{% endhighlight %}

If you want to retrieve a particular book, you might write something like this:

{% highlight python %}
book = db.query('select * from Book where id=:id', id=10)
{% endhighlight %}

If you want to retrieve the book and it's comments, a natural way would be to write something like this:

{% highlight python %}
book = db.query('select * from Book where id=:id', id=10)
reviews = db.query('select * from Review where book_id=:book_id', book_id=book.id)
{% endhighlight %}

This is OKish code to write when performance isn't an issue. In fact, it's the kind of code you'd write for databases without foreign key relationships, such as many of the NoSQL ones. However, the code, as mentioned is quite inneficient: you need two queries to retrieve the data, which means two connections and all the assorted extra bandwith and increase in latency. Finally, the database doesn't have a chance to optimize the query in any way. Not much it could do for this one, but for more sophisticated queries it does matter.
Perhaps the most important, the complexity of the query is limited. Supposed we'd want all books written in 2016 and their reviews. The code might look like: 

{% highlight python %}
books = db.query('select * from Book where year_published=:year', year=2016)
reviews = db.query('select * from Review where book_id in :book_ids', book_ids=[b.id for b in books])
{% endhighlight %}

We have a potentially large number of books being transmitted from the db. Then a large query is sent. Finally a large response is returned.

Finally, if we ever want to retrieve `Authors`, `Critics` or anything like that, the performance profile turns to rubbish.

The answer, is, of course, joins. The first query can be written as:

{% highlight python %}
book_with_reviews = db.query('''
    select b.*, r.*
    from Book as b
    join Reviews as r
    on b.id = r.book_id
    where b.id = :id
    ''', id=10)
{% endhighlight %}

One of the reasons joins are harder to grok than selects and wheres is that programmers don't have a prebuilt mental model for them. It's I think safe to assume that most people first learn one or more programming languages before coming to SQL and having to interact with the database. Hence, they have a good mental model of how "programming languages" work. So filtering a dataset or transforming one dataset to another is quite well ingrained in them as a means to solve problems. If they've had exposure to functional programming, this will be doubly so. However, most programming languages don't have `join` as a standard library function, like they have `map` or `filter`. Hence, the tool is unused. Granted, it doesn't make that much sense to have it when all the data is in main memory and easily linkable via pointers. When moving to SQL, join is this wierd construct begat by the way data is represented. It's one big source of the alieness of SQL.


