---
published: false
---
A little while ago I wrote and open-sourced a small Typescript/Javascript data marshalling library called [Raynor](https://github.com/horia141/raynor).

I want this article to serve as a tutorial and justification for its creation. To keep things interesting, here's a fairly contrived usage example, but which captures the essence none-the-less.

```
class Point {
  @MarshalWith(NumberMarshaller)
  x: number;
  
  @MarshalWith(NumberMarshaller)
  y: number;
  
  norm2(): number {
      return this.x*this.x + this.y*this.y;
  }
}

const pm = new (MarshalFrom(Point))();
const p = pm.extract({x: 10, y: 20, z: 30});
console.log(p.norm2()); // Prints out 500
```

Tutorial
---



The first concept to take note of is that of the `Marshaller`. It is the entity which transforms a _raw_ representation to a program one.

Marshallers work with JavaScript objects as inputs. This means null, booleans, numbers, strings, arrays and objects. If you've worked with other libraries like this one, you probably know that they take strings or byte streams as inputs. Raynor however doesn't deal with the "wire representation" and assumes there's some simple way of getting from the string/byte stream format to a JS object. And indeed there is. `JSON.parse`, url decoding etc. I plan on extending it to deal with this as well, but for now it isn't that urgent. There's simple and well known ways of doing this in JavaScript, and the extra complexity wasn't warranted. As outputs there are JavaScript objects as well. The simplest thing a marshaller can do is just check that a value corresponds to certain constraints and leave it like that. For example, an email marshaller might work like that. But it can also transform them. For exaple, a date time marshaller might take an number as an input and produce a DateTime object. Marshallers for classes will produce an instance of the class, rather than just checking that the input corresponds. In the initial example, we could call the `norm2` method on `p`, even though it originated in an instance of `Object`.

`Marshaller<T>` is the core interface. It looks like this:

```
interface Marshaller<T> {
    extract(raw: any): T
    pack(packed: T): any
}
```

`T` is the type the marshaller knows how to produce. The two methods `extract` and `pack` act as opposites of each other. They take and produce `any`s, so we can have Marshallers starting from numbers, strings, etc.

Raynor comes ready made with a suite of Marshallers. This is expanding over time and I hope that every basic concept a programmer might encounter would be covered. As such we have:

 - Numbers - number, integer, positive integer etc.
 - Booleans
 - Null
 - DateTime
 - String - non-empty strings, strings of a certain length etc.
 
A very common setup is to have a primitive type with a certain setup. An email is a fine example. It's a string, but it has a certain format which must be adhered to. It's very easy to implement this pattern in Raynor, as all of the basic marshallers can be extended and a filter method can be implemented to apply extra filtering. For example, say you want to express the constraint that a DateTime should be later than the year 2000. You could do it like this:

```
class PostY2KDateMarshaller extends DateTimeMarshaller {
    filter(date: DateTime): DateTime {
        if (date.year < 2000) {
            throw new ExtractError('Should be after 2000');
        }
        
        return date;
   }
}
```

You can do this because all of the basic types are descendents from `RaiseBuildFilterMarshaller`. This implements a common pattern when marshalling. First an input is checked to be OK for further processing - the Raise operation. Then an more complex object is constructed from it - the Build operation. Finally, one or more filter steps is applied, in order to define proper values.

For example, a datetime marshaller is a RaiseBuildFilterMarshaller, where the build step consists of checking that we're dealing with a positive number, build consists of transforming that number as a timestamp into a datetime object. There aren't any filter steps. A PositiveIntegerMarshaller also checks that there's a number as input, and build just leaaves the number alone. But there is a succession of two filters, one checks that we're dealing with an integer, and the last that we're dealing with a positive number.

All these are implemented as a hierarchy, which builds atop each other as much as possible.

Raynor draws heavy inspiration from [Json.Net](other) and JIL, and other C# libraries for marshalling JSON data to and from C# objects. It is distantly related to [Protocol Buffers](pb), [Thrift](thrift) etc, but there's some non-overlapping goals as well. Those are meant more for a straight-up description of the data, and have extra RPC bits as well. Raynor doesn't try to do RPC at all. Furthermore, Raynor is only for JavaScript for now, though the architecture can definitely be cloned in other languages with annotations, such as Python, C#, Java etc. But what sets Raynor apart is its attempt at further validating data than just looking at the type. An IBAN represented as a string is more than a string. It has a certain structure and only certain values are allowed.

Now, necessarily the testing is "local". The classic example is the email. A string might look like a valid email address, but it might not _be_ a valid email address. The only test for this is actually sending an email and seeing that it's received. But that's a very hard operation to do, and one which depends on the time that it's done. So if we were to do it at the time an RPC is received, it might not keep.

