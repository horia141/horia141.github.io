---
published: false
---
A little while ago I wrote and open-sourced a small Typescript/Javascript data marshalling library called [Raynor](https://github.com/horia141/raynor).

I want this article to serve as a tutorial and justification for its creation. To keep things interesting, here's a fairly contrived usage example, but which captures the essence none-the-less.

```
class Point {
  @MarshalWith(NumberMarshaller)
  x: number;
  
  @MarshalWith(NumberMarshaller)
  y: number;
  
  norm2(): number {
      return this.x*this.x + this.y*this.y;
  }
}

const pm = new (MarshalFrom(Point))();
const p = pm.extract({x: 10, y: 20, z: 30});
console.log(p.norm2()); // Prints out 500
```

Tutorial
---



The first concept to take note of is that of the `Marshaller`. It is the entity which transforms a _raw_ representation to a program one.

Marshallers work with JavaScript objects as inputs. This means null, booleans, numbers, strings, arrays and objects. If you've worked with other libraries like this one, you probably know that they take strings or byte streams as inputs. Raynor however doesn't deal with the "wire representation" and assumes there's some simple way of getting from the string/byte stream format to a JS object. And indeed there is. `JSON.parse`, url decoding etc. I plan on extending it to deal with this as well, but for now it isn't that urgent. There's simple and well known ways of doing this in JavaScript, and the extra complexity wasn't warranted. As outputs there are JavaScript objects as well. The simplest thing a marshaller can do is just check that a value corresponds to certain constraints and leave it like that. For example, an email marshaller might work like that. But it can also transform them. For exaple, a date time marshaller might take an number as an input and produce a DateTime object. Marshallers for classes will produce an instance of the class, rather than just checking that the input corresponds. In the initial example, we could call the `norm2` method on `p`, even though it originated in an instance of `Object`.

`Marshaller<T>` is the core interface. It looks like this:

```
interface Marshaller<T> {
    extract(raw: any): T
    pack(packed: T): any
}
```

`T` is the type the marshaller knows how to produce. The two methods `extract` and `pack` act as opposites of each other. They take and produce `any`s, so we can have Marshallers starting from numbers, strings, etc.

Raynor comes ready made with a suite of Marshallers. This is expanding over time and I hope that every basic concept a programmer might encounter would be covered. As such we have:

 - Numbers - number, integer, positive integer etc.
 - Booleans
 - Null
 - DateTime
 - String - non-empty strings, strings of a certain length etc.
 


Raynor draws heavy inspiration from [Json.Net](other) and JIL, and other C# libraries for marshalling JSON data to and from C# objects. It is distantly related to [Protocol Buffers](pb), [Thrift](thrift) etc, but there's some non-overlapping goals as well. Those are meant more for a straight-up description of the data, and have extra RPC bits as well. Raynor doesn't try to do RPC at all. Furthermore, Raynor is only for JavaScript for now, though the architecture can definitely be cloned in other languages with annotations, such as Python, C#, Java etc. But what sets Raynor apart is its attempt at further validating data than just looking at the type. An IBAN represented as a string is more than a string. It has a certain structure and only certain values are allowed.

Now, necessarily the testing is "local". The classic example is the email. A string might look like a valid email address, but it might not _be_ a valid email address. The only test for this is actually sending an email and seeing that it's received. But that's a very hard operation to do, and one which depends on the time that it's done. So if we were to do it at the time an RPC is received, it might not keep.

